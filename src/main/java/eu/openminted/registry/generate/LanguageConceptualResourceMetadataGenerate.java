package eu.openminted.registry.generate;


import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.util.ISO8601DateFormat;

import eu.openminted.registry.core.service.ResourceCRUDService;
import eu.openminted.registry.domain.*;
import eu.openminted.registry.service.CorpusServiceImpl;
import eu.openminted.registry.service.aai.UserInfoAAIRetrieve;


import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;

import java.io.IOException;
import java.util.*;


@org.springframework.stereotype.Component
public class LanguageConceptualResourceMetadataGenerate extends WorkflowOutputMetadataGenerate {
	
    static final Logger logger = LogManager.getLogger(LanguageConceptualResourceMetadataGenerate.class);
    
    public Lexical generateLanguageConceptualResourceMetadata(String inputCorpusId, String componentId, String userId, String outputCorpusArchiveId) throws IOException  {
    	//eu.openminted.registry.domain.Lexical
    	Lexical lcr = new Lexical();
    	lcr.setMetadataHeaderInfo(generateMetadataHeaderInfo(userId));
    	String lcrOmtdId = lcr.getMetadataHeaderInfo().getMetadataRecordIdentifier().getValue();    
    	lcr.setLexicalConceptualResourceInfo(generateLanguageConceptualResourceInfo(lcrOmtdId, inputCorpusId, componentId, userId, outputCorpusArchiveId));
    	logger.info("Output corpus metadata::\n " + mapper.writeValueAsString(lcr)+"\n");
    	return lcr;
    }

    public LexicalConceptualResourceInfo generateLanguageConceptualResourceInfo(String lcrOmtdId, String inputCorpusId, String componentId, String userId, String outputCorpusArchiveId) throws IOException {
    	 // Get input corpus information
        logger.info("Retrieving input corpus " + inputCorpusId);    
        Corpus inputCorpus = corpusService.get(inputCorpusId);
        logger.info("Input corpus:\n" + mapper.writeValueAsString(inputCorpus.getCorpusInfo()) +"\n");

        // Get component information
        logger.info("Retrieving component " + componentId);
        Component component = applicationService.get(componentId);
        logger.info("Component:\n" + mapper.writeValueAsString(component.getComponentInfo()) +"\n");
        
        LexicalConceptualResourceInfo lcrInfo = new LexicalConceptualResourceInfo();
               
        ////////////////////////
        // IdentificationInfo      
        lcrInfo.setIdentificationInfo(generateIdentificationInfo(inputCorpus, component));
        logger.info("Identification Info:\n" + mapper.writeValueAsString(lcrInfo.getIdentificationInfo()) +"\n");
        
        /////////////////////////
        // VersionInfo     
        lcrInfo.setVersionInfo(generateVersionInfo());
        logger.info("Version info:\n" + mapper.writeValueAsString(lcrInfo.getVersionInfo())+"\n");
        
        //////////////////////////
        // ContactInfo       
        lcrInfo.setContactInfo(generateContactInfo(userId, lcrOmtdId));
        logger.info("Contact info::\n" + mapper.writeValueAsString(lcrInfo.getContactInfo()) + "\n");
		        
		//////////////////////////
		// datasetDistributionInfo       
        List<DatasetDistributionInfo> distributionInfos = new ArrayList<>() ;
        distributionInfos.add(generateDatasetDistributionInfo(inputCorpus, component, outputCorpusArchiveId));
		lcrInfo.setDistributionInfos(distributionInfos);
		logger.info("Distribution info:\n" + mapper.writeValueAsString(lcrInfo.getDistributionInfos())+"\n");
		
		//////////////////////////
		// rightsInfo
        RightsInfo rightsInfo = generateRightsInfo(inputCorpus, component);
        lcrInfo.setRightsInfo(rightsInfo);
        logger.info("Rights info:\n" + mapper.writeValueAsString(rightsInfo) + "\n");    

        
        return(lcrInfo);
        		

    }

	@Override
	protected IdentificationInfo generateIdentificationInfo(Corpus inputCorpus, Component component) {

		String descriptionDescription  =  "The lexical/conceptual resource generated by the processing of " +  
		        "[input_corpus_name] with [component_name] version [component_version].";
								    		
		IdentificationInfo identificationInfo = new IdentificationInfo();
		
		// identificationInfo.resourceNames.resourceName		
		identificationInfo.setResourceNames(generateResourceNameList(inputCorpus, component));
		
		// identificationInfo.descriptions.description
		identificationInfo.setDescriptions(generateDescriptionList(inputCorpus, component, descriptionDescription));
	
		// identificationInfo.resourceIdentifiers.resourceIdentifier
		identificationInfo.setResourceIdentifiers(generateResourceIdentifierList());
		
		return identificationInfo;
	}

	@Override
	protected String getWorkingResourceName(Corpus inputCorpus, Component component) {
		String corpusName = "The lexical/conceptual resource generated by the processing of " + 
				"[input_corpus_name] with [component_name]";
		corpusName = corpusName.replaceAll("\\[input_corpus_name\\]", 
				getInputCorpusName(inputCorpus));			
		corpusName = corpusName .replaceAll("\\[component_name\\]", 
				getComponentName(component));
									
		return corpusName;
	}

	@Override
	protected String generateWorkingResourceLandingPage(String resourceOmtdId) {
		return landingPageDomain + "/landingPage/lexical/" + resourceOmtdId;
	}

	@Override
	protected String generateDistributionLocation(String outputArchiveId) {
		return registryHost + "/request/lexical/download?archiveId=" + outputArchiveId;
	}

	@Override
	protected List<SizeInfo> generateDistributionSizeInfo(Corpus inputCorpus) {
		List<SizeInfo> sizeInfoList = new ArrayList<>();
		SizeInfo sizeInfo = new SizeInfo();
		sizeInfo.setSize("1");
		sizeInfo.setSizeUnit(SizeUnitEnum.FILES);
		sizeInfoList.add(sizeInfo);
		return sizeInfoList;
	}
	
	@Override
	protected String generateAttributionTextStart(){
		return "The language description generated by the ";
	}
}